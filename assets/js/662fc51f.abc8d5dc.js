"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[2094],{1248:e=>{e.exports=JSON.parse('{"permalink":"/develbyte/blog/zookeeper-namespace-and-operations","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2016-10-27-zookeeper-namespace-and-operations.md","source":"@site/blog/2016-10-27-zookeeper-namespace-and-operations.md","title":"Zookeeper Namespace And Operations","description":"Zookeper data Model:","date":"2016-10-27T00:00:00.000Z","tags":[{"inline":false,"label":"Zookeeper","permalink":"/develbyte/blog/tags/zookeeper","description":"Apache Zookeeper coordination service"},{"inline":false,"label":"Distributed Computing","permalink":"/develbyte/blog/tags/distributed-computing","description":"Distributed computing technologies"},{"inline":false,"label":"Kafka","permalink":"/develbyte/blog/tags/kafka","description":"Apache Kafka messaging system"},{"inline":false,"label":"Coordination","permalink":"/develbyte/blog/tags/coordination","description":"System coordination and synchronization"}],"readingTime":4.63,"hasTruncateMarker":false,"authors":[{"name":"Narendra Dubey","title":"Builder of Data Systems and Software","url":"https://im-naren.github.io/about/","page":{"permalink":"/develbyte/blog/authors/narendra"},"socials":{"github":"https://github.com/im-naren","linkedin":"https://www.linkedin.com/in/im-naren/","email":"mailto:naren.dubey@zoho.com"},"imageURL":"https://github.com/im-naren.png","key":"narendra"}],"frontMatter":{"slug":"zookeeper-namespace-and-operations","title":"Zookeeper Namespace And Operations","authors":["narendra"],"tags":["zookeeper","distributed-computing","kafka","coordination"],"date":"2016-10-27T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Zookeeper Sessions and life cycle","permalink":"/develbyte/blog/zookeeper-sessions-and-life-cycle"},"nextItem":{"title":"Zookeeper Introduction to Zookeeper","permalink":"/develbyte/blog/zookeeper-introduction-to-zookeeper"}}')},3319:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var a=n(1248),o=n(4848),s=n(8453);const i={slug:"zookeeper-namespace-and-operations",title:"Zookeeper Namespace And Operations",authors:["narendra"],tags:["zookeeper","distributed-computing","kafka","coordination"],date:new Date("2016-10-27T00:00:00.000Z")},r="Zookeeper Namespace And Operations",d={authorsImageUrls:[void 0]},l=[{value:"Zookeper data Model:",id:"zookeper-data-model",level:2},{value:"Znode:",id:"znode",level:2},{value:"The ZooKeeper API exposes the following operations:",id:"the-zookeeper-api-exposes-the-following-operations",level:3},{value:"Different Modes of Znode:",id:"different-modes-of-znode",level:2},{value:"Persistent and ephemeral znodes",id:"persistent-and-ephemeral-znodes",level:3},{value:"Sequential znodes:",id:"sequential-znodes",level:3},{value:"Version:",id:"version",level:2},{value:"Watch:",id:"watch",level:2},{value:"Data Access:",id:"data-access",level:2},{value:"Semantics of Watches :",id:"semantics-of-watches-",level:2},{value:"Remove Watches:",id:"remove-watches",level:2},{value:"ACL Permissions :",id:"acl-permissions-",level:2}];function c(e){const t={code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"zookeper-data-model",children:"Zookeper data Model:"}),"\n",(0,o.jsx)(t.p,{children:"ZooKeeper has a hierarchal name space(as shown below), much like a distributed file system. The only difference is that each node in the namespace can have data associated with it as well as children. It is like having a file system that allows a file to also be a directory."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"zookeeper-data-model",src:n(6194).A+"",width:"952",height:"855"})}),"\n",(0,o.jsx)(t.p,{children:"The root node contains four more nodes, and three of those nodes have nodes under them. The leaf nodes are the data."}),"\n",(0,o.jsx)(t.h2,{id:"znode",children:"Znode:"}),"\n",(0,o.jsx)(t.p,{children:"Every node in a ZooKeeper tree is referred to as a znode.Znodes maintain a stat structure that includes version numbers for data changes, acl changes. The stat structure also has timestamps. The version number, together with the timestamp, allows ZooKeeper to validate the cache and to coordinate updates. Each time a znode's data changes, the version number increases."}),"\n",(0,o.jsx)(t.p,{children:"Znodes may or may not contain data. If a znode contains any data, the data is stored as a  byte  array.  The  exact  format  of  the  byte  array  is  specific  to  each  application,  and ZooKeeper does not directly provide support to parse it. The absence of data often conveys important information about a znode. For Example :- in a typical master-worker application the absence of a master znode means that no master is currently elected."}),"\n",(0,o.jsx)(t.h3,{id:"the-zookeeper-api-exposes-the-following-operations",children:"The ZooKeeper API exposes the following operations:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"create /path data"})," - Creates a znode named with /path  and containing data"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"delete /path"})," - Deletes the znode  /path"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"exists /path"})," - Checks whether /path exists"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"setData /path data"})," - Sets the data of znode /path to  data"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"getData /path"})," - Returns the data in /path"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"getChildren /path"})," - Returns the list of children under /path"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"One important note is that ZooKeeper does not allow partial writes or reads of the znode data. When setting the data of a znode or reading it, the content of the znode is replaced or read entirely."}),"\n",(0,o.jsx)(t.h2,{id:"different-modes-of-znode",children:"Different Modes of Znode:"}),"\n",(0,o.jsx)(t.p,{children:"Znodes can be created with four different modes: persistent, ephemeral, presistent_sequential and ephemeral_sequential"}),"\n",(0,o.jsx)(t.h3,{id:"persistent-and-ephemeral-znodes",children:"Persistent and ephemeral znodes"}),"\n",(0,o.jsx)(t.p,{children:"A znode can be either persistent or ephemeral. A persistent znode /path can be deleted only through a call to delete. An ephemeral znode, in contrast, is deleted if the client that created it crashes or simply closes its connection to ZooKeeper."}),"\n",(0,o.jsx)(t.p,{children:"Persistent znodes are useful when the znode stores some data on behalf of an application and this data needs to be preserved even after its creator is no longer part of the system."}),"\n",(0,o.jsx)(t.p,{children:"Ephemeral znodes convey information about some aspect of the application that must exist only while the session of its creator is valid."}),"\n",(0,o.jsx)(t.h3,{id:"sequential-znodes",children:"Sequential znodes:"}),"\n",(0,o.jsx)(t.p,{children:"A sequential znode is assigned a unique, monotonically increasing integer. This sequence number is appended to the path used to create the znode. For example, if a client creates a sequential znode with the path /tasks/ task-, ZooKeeper assigns a sequence number, say 1, and appends it to the path. The path of the znode becomes /tasks/task-1. Sequential znodes provide an easy way to create znodes with unique names. They also provide a way to easily see the creation order of znodes."}),"\n",(0,o.jsx)(t.h2,{id:"version",children:"Version:"}),"\n",(0,o.jsx)(t.p,{children:"Each znode has a version number associated with it that is incremented every time its data changes. A couple of operations in the API can be executed conditionally: setData and delete. Both calls take a version as an input parameter, and the operation succeeds only if the version passed by the client matches the current version on the server. The use of versions is important when multiple ZooKeeper clients might be trying to perform operations over the same znode."}),"\n",(0,o.jsx)(t.h2,{id:"watch",children:"Watch:"}),"\n",(0,o.jsx)(t.p,{children:"A watch is a one-shot operation, which means that it triggers one notification for any changes to znodes. Registering to receive a notification for a given znode consists of setting a watch. To receive multiple notifications over time, the client must set a new watch upon receiving each notification."}),"\n",(0,o.jsx)(t.h2,{id:"data-access",children:"Data Access:"}),"\n",(0,o.jsx)(t.p,{children:"The data stored at each znode in a namespace is read and written atomically. Reads get all the data bytes associated with a znode and a write replaces all the data. Each node has an Access Control List (ACL) that restricts who can do what."}),"\n",(0,o.jsx)(t.p,{children:"ZooKeeper was not designed to be a general database or large object store. Instead, it manages coordination data. This data can come in the form of configuration, status information, rendezvous, etc."}),"\n",(0,o.jsx)(t.h2,{id:"semantics-of-watches-",children:"Semantics of Watches :"}),"\n",(0,o.jsxs)(t.p,{children:["We can set watches with the three calls that read the state of ZooKeeper: ",(0,o.jsx)(t.code,{children:"exists"}),", ",(0,o.jsx)(t.code,{children:"getData"}),", and ",(0,o.jsx)(t.code,{children:"getChildren"}),".The following list details the events that a watch can trigger and the calls that enable them:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Created event"}),": Enabled with a call to exists."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Deleted event"}),": Enabled with a call to exists, ",(0,o.jsx)(t.code,{children:"getData"}),", and ",(0,o.jsx)(t.code,{children:"getChildren"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Changed event"}),": Enabled with a call to exists and ",(0,o.jsx)(t.code,{children:"getData"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Child event"}),": Enabled with a call to ",(0,o.jsx)(t.code,{children:"getChildren"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"remove-watches",children:"Remove Watches:"}),"\n",(0,o.jsxs)(t.p,{children:["We can remove the watches registered on a znode with a call to ",(0,o.jsx)(t.code,{children:"removeWatches"}),". Also, a ZooKeeper client can remove watches locally even if there is no server connection by setting the local flag to true. The following list details the events which will be triggered after the successful watch removal."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Child Remove event"}),": Watcher which was added with a call to ",(0,o.jsx)(t.code,{children:"getChildren"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Data Remove event"}),": Watcher which was added with a call to exists or ",(0,o.jsx)(t.code,{children:"getData"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"acl-permissions-",children:"ACL Permissions :"}),"\n",(0,o.jsx)(t.p,{children:"ZooKeeper supports the following permissions:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"CREATE"}),": you can create a child node"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"READ"}),": you can get data from a node and list its children."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"WRITE"}),": you can set data for a node"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"DELETE"}),": you can delete a child node"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"ADMIN"}),": you can set permissions"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},6194:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/zookeeper-data-model-044b9ead4041c341472dd8d2f8d11e34.png"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(6540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);